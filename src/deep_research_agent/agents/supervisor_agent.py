"""
Research Supervisor Agent

Plans research strategy and coordinates multiple research agents.
Implements the supervisor orchestration logic from the Deep Research Agent Implementation Guide.
"""

import asyncio
from typing import List
from datetime import datetime
from agents import (
    Agent,
    AgentOutputSchema,
    RunContextWrapper,
    Runner,
    function_tool,
    ModelSettings,
)
from ..models import SupervisorDecision, ResearchContext, ResearchTask, ResearchStatus
from ..tools import conduct_research, research_complete
from ..config import DeepResearchConfig
from ...api.utils.logging import get_logger

logger = get_logger(__name__)


class ResearchSupervisor:
    def __init__(self, max_concurrent_units: int, max_iterations: int):
        self.max_concurrent_units = max_concurrent_units
        self.max_iterations = max_iterations

    async def _plan_research_iteration(
        self, ctx: RunContextWrapper[ResearchContext]
    ) -> SupervisorDecision:
        """
        Asks the supervisor agent (LLM) to plan the next research iteration.
        """
        current_findings_summary = (
            "\n".join(ctx.context.research_findings)
            if ctx.context.research_findings
            else "No findings yet."
        )
        research_brief_content = (
            ctx.context.research_brief or "No research brief provided."
        )

        prompt = get_supervisor_instructions(
            self.max_concurrent_units,
            self.max_iterations,
            research_brief_content,
            current_findings_summary,
            ctx.context.current_iteration,
        )

        config = DeepResearchConfig.from_environment()

        supervisor_agent_instance = Agent["ResearchContext"](
            name="Research Supervisor",
            instructions=prompt,
            model=config.supervisor_model_name,
            tools=[conduct_research, research_complete],
            output_type=AgentOutputSchema(SupervisorDecision, strict_json_schema=False),
        )

        # The LLM's response is a SupervisorDecision, which will contain tool calls
        response = await Runner.run(
            starting_agent=supervisor_agent_instance,
            input="Make your decision for the next research step.",
            context=ctx.context,
        )
        return response.final_output

    async def _execute_research_tasks(
        self,
        ctx: RunContextWrapper[ResearchContext],
        research_tasks: List[ResearchTask],
    ):
        """
        Executes research tasks in parallel.
        """
        active_tasks = research_tasks[: self.max_concurrent_units]
        logger.info(f"Executing {len(active_tasks)} research tasks in parallel.")

        # Create a list of coroutines for parallel execution
        tasks_to_run = [conduct_research(ctx, task.topic) for task in active_tasks]

        # Execute in parallel and collect results
        # Note: asyncio.gather returns results in the order the awaitables were passed
        results = await asyncio.gather(*tasks_to_run, return_exceptions=True)

        for i, result in enumerate(results):
            if isinstance(result, Exception):
                logger.error(
                    f"Error executing research task '{active_tasks[i].topic}': {result}"
                )
                ctx.context.error_message = str(result)
            else:
                # conduct_research already appends to context.research_findings
                logger.info(
                    f"Research task '{active_tasks[i].topic}' completed successfully."
                )

    def _should_terminate_research(
        self,
        ctx: RunContextWrapper[ResearchContext],
        supervisor_decision: SupervisorDecision,
    ) -> bool:
        """
        Determines if the overall research process should terminate.
        """
        # Termination if max iterations reached
        if ctx.context.current_iteration >= self.max_iterations:
            logger.info(
                f"Terminating research: Maximum iterations ({self.max_iterations}) reached."
            )
            return True

        # Termination if supervisor explicitly calls research_complete
        if supervisor_decision.action == "complete_research":
            logger.info(
                f"Terminating research: Supervisor signaled completion with reason: {supervisor_decision.completion_reason}"
            )
            return True

        # Termination if no new research tasks were generated in this iteration
        if (
            not supervisor_decision.research_tasks
            and supervisor_decision.action != "complete_research"
        ):
            logger.info(
                "Terminating research: No new research tasks generated by supervisor, and not explicitly completing."
            )
            return True

        return False

    async def run_supervisor_orchestration(
        self, ctx: RunContextWrapper[ResearchContext], input_query: str
    ) -> str:
        """
        Main orchestration loop for the research supervisor.
        """
        ctx.context.research_brief = (
            input_query  # The input query becomes the initial research brief
        )
        ctx.context.current_iteration = 0

        while True:
            ctx.context.current_iteration += 1
            logger.info(
                f"Supervisor orchestration: Starting iteration {ctx.context.current_iteration}/{self.max_iterations}"
            )

            # Phase 1: Planning - LLM decides next steps
            supervisor_decision = await self._plan_research_iteration(ctx)
            ctx.context.supervisor_decisions.append(supervisor_decision.model_dump())

            # Phase 2: Check Termination Conditions
            if self._should_terminate_research(ctx, supervisor_decision):
                ctx.context.status = ResearchStatus.COMPLETED
                return f"Research orchestration completed. Final findings: {ctx.context.research_findings}"

            # Phase 3: Execute Research Tasks (if any)
            if supervisor_decision.research_tasks:
                await self._execute_research_tasks(
                    ctx, supervisor_decision.research_tasks
                )
            else:
                logger.info(
                    "Supervisor decided not to conduct any new research tasks in this iteration."
                )


def get_supervisor_instructions(
    max_concurrent_units: int,
    max_iterations: int,
    research_brief: str,
    current_findings: str,
    current_iteration: int,
) -> str:
    """Get instructions for the research supervisor agent."""
    current_date = datetime.now().strftime("%A, %B %d, %Y")

    instructions_content = f"""You are a senior research supervisor responsible for planning and coordinating comprehensive research investigations. Your role is to analyze research briefs, identify knowledge gaps, and orchestrate multiple specialized researchers to conduct thorough investigations.

Current Date: {current_date}
Maximum Concurrent Research Units: {max_concurrent_units}
Maximum Research Iterations: {max_iterations}
Current Iteration: {current_iteration}

RESEARCH BRIEF: {research_brief}
CURRENT FINDINGS: {current_findings}

CORE RESPONSIBILITIES:

1. **Strategic Research Planning**
   - Analyze the RESEARCH BRIEF and CURRENT FINDINGS to identify key information needs and knowledge gaps.
   - Break complex topics into focused, researchable sub-topics.
   - Determine optimal research sequence and parallelization opportunities.
   - Assess required research depth and breadth.

2. **Resource Coordination**
   - Decide whether to launch new research tasks using `conduct_research` or if the overall research is complete and can be signaled using `research_complete`.
   - Consider the `Maximum Concurrent Research Units` and `Maximum Research Iterations`.

3. **Gap Analysis**
   - Continuously assess what information has been gathered against the RESEARCH BRIEF.
   - Identify critical knowledge gaps that still need addressing.
   - Determine when sufficient research has been completed.

4. **Decision Making**
   - Choose specific research topics for `conduct_research` and provide detailed context for each.
   - Provide clear reasoning for completing research if you choose `research_complete`.

AVAILABLE TOOLS:

1. **conduct_research(research_topic)**
   - Use this to spawn and run specialized researcher agents on specific topics.
   - Provide the research topic for focused investigation.
   - Each call creates and executes a researcher with access to Tavily MCP tools.
   - You can call this multiple times for different topics within a single decision, up to `Maximum Concurrent Research Units`.
   - Returns actual research findings, not just instructions.

2. **research_complete(reason, confidence_level)**
   - Use this when research is sufficiently comprehensive.
   - Provide clear reasoning for completion.
   - Include confidence level in research completeness (0-1).
   - This signals the end of the research phase.

DECISION CRITERIA (for your reasoning):

**When to Conduct More Research:**
- Critical knowledge gaps remain unfilled based on the RESEARCH BRIEF and CURRENT FINDINGS.
- Research brief objectives not yet met.
- Current iteration count < {max_iterations}.
- Findings lack sufficient depth or verification.

**When to Complete Research:**
- Core research objectives have been substantially addressed.
- Diminishing returns from additional research are expected.
- High confidence in findings comprehensiveness (>0.8).
- Maximum iterations reached ({max_iterations}).
- All major aspects of the research brief are covered.

Remember: Your goal is to orchestrate a comprehensive research investigation by *making decisions* that the Python execution environment will then carry out. Your output should be a structured `SupervisorDecision` that can be directly interpreted by the system. Do not perform the research yourself, only decide on the next steps."""

    return instructions_content


def create_supervisor_agent(
    max_concurrent_units: int = 5, max_iterations: int = 3
) -> Agent[ResearchContext]:
    """
    Create the research supervisor agent.

    This agent will delegate its execution to the ResearchSupervisor class.

    Args:
        max_concurrent_units: Maximum number of parallel research units
        max_iterations: Maximum number of research iterations
    """
    supervisor_orchestrator = ResearchSupervisor(max_concurrent_units, max_iterations)

    @function_tool
    async def run_research_orchestration(
        ctx: RunContextWrapper[ResearchContext], input_query: str
    ) -> str:
        """Orchestrate the complete research process."""
        return await supervisor_orchestrator.run_supervisor_orchestration(
            ctx, input_query
        )

    return Agent[ResearchContext](
        name="Research Supervisor",
        instructions="You are the Research Supervisor. Your decisions will guide the research process. Be precise and use the provided tools.",
        model=DeepResearchConfig.from_environment().supervisor_model_name,
        tools=[run_research_orchestration],
        model_settings=ModelSettings(tool_choice="required"),
        tool_use_behavior="stop_on_first_tool",
    )


supervisor_agent = create_supervisor_agent()
